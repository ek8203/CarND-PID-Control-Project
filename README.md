
### Sefl-Driving Car Nanodegree Program. Term 2
<img style="float: left;" src="https://s3.amazonaws.com/udacity-sdc/github/shield-carnd.svg">

## Project 9: PID controller

### Overview
---
The goal of this project is to build a PID controller and tune the PID hyperparameters by applying the general processing flow as described in the class lessons.

The project includes following steps:
* Completion of the [project template](https://github.com/udacity/CarND-PID-Control-Project) C++ source code in order to build a PID controller by applying the general processing flow as described in the class lessons
* Test the PID controller implementation with input data generated by the [Term 2 Simulator](https://github.com/udacity/self-driving-car-sim/releases)
* Tune the PID hyperparameters to level that allows the vehicle to drive successfully around the full track.

### Project directory content:

* [README.md](README.md) - This file.
* [src/](src/) folder:
   - project C++ source code files
   - [CMakeLists.txt](src/CMakeLists.txt) - `cmake` input file to generate the project `Makefile`. It was moved to the `src` folder and adopted to generate an `Eclipse` project - thanks to [Eclipse IDE profile](https://github.com/udacity/CarND-Extended-Kalman-Filter-Project/tree/master/ide_profiles/Eclipse) repo for provided instructions. 
* [data/](data/) folder:
    - [pid_output.txt](data/pid_output.txt) - output data file with error and angle recodings for tuning hyperparameters
    - [pid_tuning.ipynb](data/pid_tuning.ipynb) - IPython notebook that is using the output data file [pid_output.txt](data/pid_output.txt) for visualization and parameter tuning

### Project Environment


The project code was built and executed on a Linux VMware guest.

### Project Build instructions

1. Make a build directory: `mkdir build && cd build`
2. Compile the code: `cmake ../src/ && make` (Please note that `CMakeList.txt` file is located in folder `src/`)
3. Run the code: `./pid`. The full format of the command string: `./pid <target_speed> <twiddle> <Kp> <Ki> <Kd>`, where:
    - `target_speed` - desired target speed (default 20mph)
    - `twiddle` - if set to 1 then anables twiddle (default - disabled)
    - `Kp` - proportional gain (default 0.15)
    - `Ki` - integral gain (default 0.15)
    - `Kd` - differencial gain (default 0.75)


### PID hyperparameters optimization and test results

After an initial implementation of the PID controller I manually tuned the hyperparameters to drive first 200-300 time steps. I found it hard to control the car at high speed, so I limited the dring speed to `10 mph` by adding a PID controller for speed control. The initial tests gave me a sense of P, I and D parameters. Decreasing the P and I terms added stability but reduced the car response on curves making it hard to pass sharp turns of the road. High values of P and I terms improved response time but made the driving unstable. The D term helped to reduce the overshoot and added some stability but only up to some level where the system oscilated again. The manual tuning was slow and challenging process.

With help of some forum [posts](https://discussions.udacity.com/t/how-can-i-connect-the-lesson-from-python-and-project-code/326414)
I found better parameter set using Ziegler-Nichols method. The method required to know the oscillation period Pu, so I created the [pid_tuning.ipynb](data/pid_tuning.ipynb) IPython notebook to analize the driving data and to calculate the hyperparameters. The driving data is stored in the file [pid_output.txt](data/pid_output.txt) in the `main()` function. That method gave me good initial results, but the system response was still slow on curves. So I tuned the P and I values manually to pass the sharp turns of the road and drived a full track at low speed.

The next step was to try to drive the car faster. I setup the target speed at `20 mph` and used the above method to find the initial P, I and D values. But at higher speed it was not that easy to make manual adjuatments of the parameters, so I added a twiddle method to the PID controller class using the algorithm from the class lesson but implemented it as state machine with error threshold of 0.2. The forum links helped to reset the simulator in order to twiddle automatically. After getting a set of the hyperparameters from twiddling I manually made the fine tuning.

I ended up with the following parameter set: `Kp = 0.15`, `Ki = 0.15` and `Kd = 0.75`. With that parameter set I am able to run multiple full tracks in the simulator with speed up to 25 mph.

### Issues

An error `"Segmentation fault (core dumped)"` is reported after `h.onDisconnection()` call.
